{- | Parser/loader for the ASCII form of font layout data generated by BMFont
 https://www.angelcode.com/products/bmfont/
-}

{-# language OverloadedStrings #-}
module Quern.Font.BMFont
  ( Font(..)
  , parseBMFont
  , parseBMFontFile
  ) where

import qualified Data.ByteString as BS
import qualified Data.ByteString.Char8 as B8
import Data.IntMap.Strict (IntMap)
import qualified Data.IntMap.Strict as IM
import qualified Data.Text.Encoding as TE
import Control.Applicative
import Data.Attoparsec.ByteString (word8)
import Data.Attoparsec.ByteString.Char8
import Data.ByteString (ByteString)
import Data.Char (ord)
import Data.Foldable (foldl')
import Data.Word (Word8)
import Linear
import Quern.Font.Types

parse_fontInfo :: Parser Info
parse_fontInfo = string "info" *> skipSpace *> (Info
  <$> (TE.decodeUtf8 <$> parse_namedString "face")
  <*> parse_namedInt "size"
  <*> parse_namedBool "bold"
  <*> parse_namedBool "italic"
  <*> parse_charSet
  <*> (Pct <$> parse_namedInt "stretchH")
  <*> parse_namedBool "smooth"
  <*> parse_namedInt "aa"
  <*> (string "padding=" *> (V4 <$> parse_intComma <*> parse_intComma <*> parse_intComma <*> parse_int))
  <*> (string "spacing=" *> (V2 <$> parse_intComma <*> parse_int))
  <*> parse_namedInt "outline")

parse_fontCommon :: Parser Common
parse_fontCommon = string "common" *> skipSpace *> (Common
  <$> parse_namedInt "lineHeight"
  <*> parse_namedInt "base"
  <*> (V2 <$> parse_namedInt "scaleW" <*> parse_namedInt "scaleH")
  <*> parse_namedInt "pages"
  <*> parse_namedBool "packed"
  <*> (argb <$> parse_namedInt "alphaChnl"
            <*> parse_namedInt "redChnl"
            <*> parse_namedInt "greenChnl"
            <*> parse_namedInt "blueChnl"))

argb :: a -> a -> a -> a -> V4 a
argb a r g b = V4 r g b a

parse_fontPages :: Parser (IntMap Page)
parse_fontPages = IM.fromList <$> many1 ((,) <$> (string "page" *> skipSpace *> parse_namedInt "id") <*> (Page <$> parse_namedString "file"))

parse_character :: Parser Character
parse_character = Character
  <$> (V2 <$> parse_namedInt "x" <*> parse_namedInt "y")
  <*> (V2 <$> parse_namedInt "width" <*> parse_namedInt "height")
  <*> (V2 <$> parse_namedInt "xoffset" <*> parse_namedInt "yoffset")
  <*> parse_namedInt "xadvance"
  <*> parse_namedInt "page"
  <*> parse_namedInt "chnl"

parse_characterId :: Parser (Int, Character)
parse_characterId = string "char" *> skipSpace *> ((,) <$> (parse_namedInt "id") <*> parse_character)

parse_fontChars :: Parser (IntMap Character)
parse_fontChars = IM.fromList <$> many1 parse_characterId

parse_fontKerning :: Parser (Int,Int,Int)
parse_fontKerning = string "kerning" *> skipSpace *> ((,,) <$> parse_namedInt "first" <*> parse_namedInt "second" <*> parse_namedInt "amount")

parse_fontKernings :: Parser (IntMap (IntMap Int))
parse_fontKernings = kernMap <$> many1 parse_fontKerning

kernMap :: [(Int,Int,Int)] -> IntMap (IntMap Int)
kernMap = foldl' (\im (a,b,x) -> IM.insertWith mappend a (IM.singleton b x) im) mempty

bmfont :: Parser Font
bmfont = Font
  <$> parse_fontInfo
  <*> parse_fontCommon
  <*> parse_fontPages
  <*> (string "chars" *> skipSpace *> parse_namedInt "count")
  <*> parse_fontChars
  <*> (string "kernings" *> skipSpace *> parse_namedInt "count")
  <*> parse_fontKernings

parseBMFont :: ByteString -> Either String Font
parseBMFont = parseOnly bmfont

parseBMFontFile :: FilePath -> IO (Either String Font)
parseBMFontFile f = BS.readFile f >>= pure . parseBMFont

-- parser utilities
eq_sign :: Word8
eq_sign = fromIntegral (ord '=')

neg_sign :: Word8
neg_sign = fromIntegral (ord '-')

comma :: Word8
comma = fromIntegral (ord ',')

quote :: Word8
quote = fromIntegral (ord '"')

parse_int :: Parser Int
parse_int = do
  neg <- (True <$ word8 neg_sign) <|> pure False
  digs <- many1' digit
  let val = read digs
  skipSpace
  if neg
    then pure (negate val)
    else pure val

parse_intComma :: Parser Int
parse_intComma = parse_int <* word8 comma

parse_namedInt :: ByteString -> Parser Int
parse_namedInt pre = (string (BS.snoc pre eq_sign) *> parse_int) <?> ("named integer: " ++ B8.unpack pre)

parse_namedString :: ByteString -> Parser ByteString
parse_namedString pre = (string pre *> word8 eq_sign *> word8 quote *> takeTill (== '"') <* (word8 quote *> skipSpace)) <?> ("named string: " ++ B8.unpack pre)

parse_namedBool :: ByteString -> Parser Bool
parse_namedBool pre = (string pre *> word8 eq_sign *> ((/= 0) <$> parse_int) <* skipSpace) <?> ("named boolean: " ++ B8.unpack pre)

parse_charSet :: Parser (Maybe ByteString)
parse_charSet = do
  c <- parse_namedString "charset"
  i <- parse_namedInt "unicode"
  case i of
    0 -> pure (Just c)
    _ -> pure Nothing
